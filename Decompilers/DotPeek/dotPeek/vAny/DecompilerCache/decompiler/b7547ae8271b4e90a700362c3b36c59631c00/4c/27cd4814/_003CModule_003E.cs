// Decompiled with JetBrains decompiler
// Type: <Module>
// Assembly: Netlimiter++, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: B7547AE8-271B-4E90-A700-362C3B36C596
// Assembly location: C:\Users\woof\Desktop\nlsetup-main\bin\x64\Release\Netlimiter++.exe

using System;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Threading;

internal class \u003CModule\u003E
{
  internal static byte[] \u200B‍‌‫‏⁪‌‪‬‫‍⁫‏​‌‎‌‬‫‭‌‫‭​⁯⁬⁫‌‌‭⁫‍‭‎‎‌‮‌⁬‮‮;
  internal static \u003CModule\u003E.\u206D⁯‪‬​‎⁪⁬⁭‎‪​⁬​‪‌‮⁭⁭​‫‪‫‎‫‫‬‎⁮‏‫‫⁯‫​‏⁫‍⁯‏‮ \u202D‭⁫⁯⁫‏⁪‏⁭‮‌‬‍‬‎‫‏⁭‫⁫‭‍​‭‬‭‮⁭​‭⁯​⁭‌‫⁭‫⁯‬‮‮;
  internal static Assembly \u206A‭‍⁫‏‬‏⁫‫⁯​⁮⁭​⁭‪‏​⁬⁫‏​‮‎⁫⁬‫‌⁭⁫‍‍‪‌‪⁪‮‪‮‍‮;
  internal static \u003CModule\u003E.\u202D⁯‮⁯‬⁯‬⁬⁫⁭⁬⁫⁬‭⁭⁯⁮⁬‭⁪‍‭⁮⁬⁪⁯⁮‪​‫⁯‫⁬‭‌⁫‍‍⁯‫‮ \u202A‌⁪⁪‍‮‌‍‮⁭‬⁯‍⁮‫⁮‎‏⁬‫‫‎‏‍⁫⁫⁬‭​‌​‪‫‬⁪⁬⁫‍‬⁪‮;

  static \u003CModule\u003E()
  {
    \u003CModule\u003E.\u206D‪‏‮‏⁫⁬⁪⁫⁫‍‎‍⁭‫‪‏‍⁪⁯‬⁫‏‪⁬‭⁬‪⁪⁬‫‪‍‌⁪‌⁫⁫‍‭‮();
label_1:
    int num1 = 325468957;
    while (true)
    {
      uint num2;
      switch ((num2 = (uint) (num1 ^ 1596694805)) % 5U)
      {
        case 0:
          \u003CModule\u003E.\u202A‭⁯‮​‪⁯‭‮‬‬‏‍⁫⁮‍⁮‫⁯‏‏⁬⁪⁮​⁫‍‫⁪‬⁯​‮‏​​⁫‮‏⁪‮();
          num1 = (int) num2 * -1548343265 ^ -1165654386;
          continue;
        case 1:
          \u003CModule\u003E.\u202C‭‭‍⁬‪​‭‍⁪‭‏‌⁯​‬⁮⁭⁪‬⁬‌⁭⁭‮‌‎‍⁪⁫‎‭‎‮⁭‎⁬‎⁪‫‮();
          num1 = (int) num2 * -494456866 ^ 1063367371;
          continue;
        case 2:
          \u003CModule\u003E.\u202D⁭‭‮‏⁭⁬‎‍‎⁮⁮⁯‭⁯‭⁫⁫‌‏‌⁬‮⁬‬‍⁭⁪‭​⁮‬‬‫⁪‎‬‏⁪‭‮();
          \u003CModule\u003E.\u200C‍⁭‮‮‫⁫⁮​‪‪‏‏‭⁮‏‏⁬‮⁯⁫‬⁫​⁮‫⁮‬⁬⁪‭‍‍⁪‍‭​⁫⁫‎‮();
          num1 = (int) num2 * -992271752 ^ -1839565238;
          continue;
        case 3:
          goto label_1;
        case 4:
          goto label_3;
        default:
          goto label_7;
      }
    }
label_3:
    return;
label_7:;
  }

  private static void \u202A‭⁯‮​‪⁯‭‮‬‬‏‍⁫⁮‍⁮‫⁯‏‏⁬⁪⁮​⁫‍‫⁪‬⁯​‮‏​​⁫‮‏⁪‮()
  {
    // ISSUE: unable to decompile the method.
  }

  private static void \u200C‎‍⁮​⁮⁬⁯‬⁯‏‍‫‮​‏⁭‍‪‌⁮‏‮​⁫‮‭⁭‪‏​⁯‎‪⁪⁭⁫‮⁫‮‮([In] object obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  [DllImport("kernel32.dll", EntryPoint = "VirtualProtect")]
  internal static extern unsafe bool \u200B‌‭‮‭⁮‭⁪⁬‍⁯⁯⁯⁯⁬⁪⁫​‏⁬‎‪‫‎⁮‍‫‏‪‍‮⁯⁬⁪‭‌‪‬‭⁪‮(
    [In] byte* obj0,
    [In] int obj1,
    [In] uint obj2,
    [In] ref uint obj3);

  internal static void \u202C‭‭‍⁬‪​‭‍⁪‭‏‌⁯​‬⁮⁭⁪‬⁬‌⁭⁭‮‌‎‍⁪⁫‎‭‎‮⁭‎⁬‎⁪‫‮()
  {
    // ISSUE: unable to decompile the method.
  }

  static Type \u206A‎⁭‮‪​‌‌‍‍‪⁯‭​​‪⁬‭‌‫‭‭⁪​⁬‌‌‭‎‭‭​⁭‌‪⁯⁫⁬‭‬‮([In] RuntimeTypeHandle obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static Type \u206F⁫‌⁯‪‭⁮‭⁮⁭​⁯‪‏⁫​⁪‮⁪‌‌​‮​‭⁭​‪‍​‪‭‭‬‏‎‪‮⁭‮‮([In] RuntimeTypeHandle obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static MethodInfo \u200E⁫‍⁪‍⁬​‌‏⁮⁯‎⁬⁬‭⁭⁭⁭‫‭‏⁮⁯‍⁬⁭‎‬⁫‪⁭​‮‎⁫‍‮⁮‏‍‮(
    [In] Type obj0,
    [In] string obj1,
    [In] Type[] obj2)
  {
    // ISSUE: unable to decompile the method.
  }

  static string \u200D⁪⁫‌‪‭‪‭‮‪‍​⁬⁭⁬⁫‎‎‏​⁪‬‭⁪⁭‬‮‫⁭⁭‮⁬⁭⁪⁯‏⁮‮‬‎‮([In] string obj0, [In] string obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static object \u206B⁯‏⁫‌‮‏⁫⁮‎‭​‎​⁭‭‬‏‭⁫‪‮⁬‎‭‏⁪‍​‪‮‭‌‎⁭‫⁯⁮‭‌‮(
    [In] MethodBase obj0,
    [In] object obj1,
    [In] object[] obj2)
  {
    // ISSUE: unable to decompile the method.
  }

  static bool \u202A⁫‫‬‏‍⁫⁫‎‎⁪‮‫⁭‬⁫⁭⁮​⁯⁮‏‭​⁫‬‪‎⁯‫⁫⁬‎⁮‎⁭‫‪⁬‮([In] object obj0, [In] object obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u200C‬⁫⁮‮‫‪⁫⁯‭‌⁫‍⁬⁬⁯‬‬‭⁬⁬⁫‏‫⁪⁯⁮​⁮⁫‍​‫‭⁫‎‎⁭‏⁫‮([In] string obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static Thread \u206A​‬‬‬‍⁬‬‎‏‫‭⁮‌‭‪⁯‌‮⁫⁮⁮⁮‮‫⁮⁮‍‪⁭⁬‪⁪⁮‮⁫⁮‌⁮‏‮([In] ParameterizedThreadStart obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u202C⁫‏⁮‮​‫​‮​‮‪‎⁮‪‪‭‫‌‏‪‫‍⁭⁬‭⁮‭‎⁪​‫⁭⁬⁪⁮‍⁫‫‍‮([In] Thread obj0, [In] bool obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u206D‏‭‪‏⁫⁮⁫‌‫⁫‮‌⁬⁮‬‍‎‍⁪‌⁪⁮⁭‎‌‬‎‏⁮‪⁪⁫‍‫‏‏⁫​‭‮([In] Thread obj0, [In] object obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static Thread \u200B‏‮⁯‏‫​‪⁫‬‬⁯⁫‎‬‌‬‫‬‮⁪⁯⁭⁮‫‌⁯‌⁯‭⁫‎⁫‌‮‌⁪‍⁭‮‮([In] ParameterizedThreadStart obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u200C‏‎​⁮⁭⁬​‍‫⁪⁯‪‪⁮‬⁪⁬‏‬‫‎‍‬⁬‫‫‮‌⁮‌⁭‬‎⁪⁭⁬‫​‬‮([In] Thread obj0, [In] bool obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static Thread \u200E⁪⁮​‮‮‬⁯‬‮‪​‫‌‫⁭⁪⁬⁯⁭‫‪‪‎⁫‬‫‭‎⁪‌‮⁯⁬​‎‬⁭‫⁪‮()
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u206F⁫‫‮⁬‌‫‫‮⁯​‏‎​‭‪‮⁬⁫⁯‎⁭⁬⁮​‭‪⁭⁪‫‮‬⁮⁮‫⁮⁬​‍⁫‮([In] Thread obj0, [In] object obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u202B‎⁭⁫‭⁭⁭‍‍​‪⁯⁯‪‮⁬‭‮⁭⁭‪‏⁫‌⁫⁯‭‬‮⁪⁭‌‭‎⁭⁯⁭‭‫⁯‮([In] int obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static bool \u206E‎‭‭‏‬⁫‎‪⁬⁯‮⁪⁬⁮‎⁮​‫⁮‪‌‌​⁭⁬‪‬​⁭‭‪‭‫‪‍‬⁯⁭‮‮()
  {
    // ISSUE: unable to decompile the method.
  }

  static bool \u202C⁭⁯‮​⁬‭⁯‮⁪⁪‎‌⁬‬‍⁭‬‎⁯⁭‌​‌⁬⁪‪‪⁮‬⁭‮‭‭‭⁯⁮‪‬‏‮()
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u206D‮⁪⁯‪​⁮‬‮‏‍⁭⁪​‫‭⁭⁯​⁮‍‭⁮‮‮⁬⁮⁭​⁬‮⁯‬‬⁪⁯⁭⁫‬‭‮([In] string obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static bool \u200E⁪‬‌⁬⁮‎⁪​‪‫⁭⁫⁮‮⁫​‬⁬⁬⁭‭⁭​‭‭⁫⁯⁬‬‎⁮‎‮⁫‏⁬‎‎‌‮([In] Thread obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u202A‬​⁯‪⁭​⁭⁯‮⁭⁮‭‬‫‮‏⁫⁪‮‭‎⁪⁮‮‬‮‎⁫‭‪⁬‫‍⁭‍‮‌‌⁭‮([In] string obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u200C⁯‍⁪⁫⁭​⁫⁯‌⁪⁪⁪‫⁫⁮⁫‎‮‍‍‌⁮⁯‌‍⁪‭⁫‍​‏‎‌‮⁬‫⁮⁭‭‮([In] int obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static Type \u202D‫‍‍‮⁫⁬‎⁬​‮‭‭‮‭‏⁬⁮​‭‌​‍‏‫‎‎‍‍‭‌⁯‪‮⁫‎‎⁪⁭⁮‮([In] RuntimeTypeHandle obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static Module \u200F‬⁭‮‫⁬​‫‭‎‪⁪​‪‌⁭‮‬‮‮‎​⁮⁭‏‭‎⁯‬‪⁯⁯‫⁬⁯​‎‮⁬⁪‮([In] Type obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static IntPtr \u206B‫‌‬‍⁮⁪‪‪⁭⁮⁯⁪‫‮⁯⁬‎‎‪‮‌‪​‌‫‌⁭‪‭‮⁬⁭⁬‍‎⁫⁪‬‭‮([In] Module obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static string \u206B⁯⁬‎⁬​‎‪‭​⁫‌⁪‬⁮‏‎‏‪⁭⁪⁪​⁪⁪⁮‎‬‭⁬‮⁯‏⁮‬‍⁫⁬⁭⁫‮([In] Module obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static char \u206A⁫‍‪‪⁮⁫‍⁬⁯⁮⁭⁭⁮‎‍‮‎⁯​⁯‌‭⁮‪‌‍‏‎‮‌⁪⁪‎‪‮‏‍‎‪‮([In] string obj0, [In] int obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u200B⁬​‮⁭‌‎⁪⁪⁭⁫‭⁬‫‬⁪‭⁭‮​‭‭‌⁮‪⁯⁭​‫⁫‏⁭⁫‏⁭‎‪‫‎‎‮(
    [In] byte[] obj0,
    [In] int obj1,
    [In] IntPtr obj2,
    [In] int obj3)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u206F⁯⁭‎​‪⁮‌‎⁮⁮‏‎‭‫​‍‫‏⁮‫​⁭‎‎⁭​‌‭⁪‫‮‮‍‫‮⁭‬⁫⁮‮(
    [In] byte[] obj0,
    [In] int obj1,
    [In] IntPtr obj2,
    [In] int obj3)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static byte[] \u206F‬‍‫‪⁫‎‬⁬⁬‏‍‮‪⁪⁯‏‍⁭⁬‏⁫‭⁬‬⁭‎⁮​⁬‭‌⁮‫‪‎​⁮‎⁫‮([In] byte[] obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static void \u200C‍⁭‮‮‫⁫⁮​‪‪‏‏‭⁮‏‏⁬‮⁯⁫‬⁫​⁮‫⁮‬⁬⁪‭‍‍⁪‍‭​⁫⁫‎‮()
  {
    // ISSUE: unable to decompile the method.
  }

  internal static \u002D \u200C⁫‮‭⁬‭‌‌⁫⁪‫⁮‭⁭‫‍‍‫⁭‪‏‬⁬‍‌⁫⁪⁯‍⁬‭⁯‮⁯⁭‭‬‫​⁬‮<\u002D>([In] uint obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static \u002D \u206E⁯‌​⁯​‪‭‎‫⁯⁪⁯⁮​​⁭​⁬⁫‮‪⁪‪⁭⁭‮⁪​‮‍‎⁯⁬⁮⁫⁪‏‎‌‮<\u002D>([In] uint obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static \u002D \u202D‌‏⁫⁬‪‭⁪⁬⁭‮⁬⁭‏⁯‮‎‮⁮⁯‌‮‎‮‎‎⁮‫⁫‪‭​‪⁫⁭‮‪‍‌‍‮<\u002D>([In] uint obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static \u002D \u206A​‫⁭‫⁫‫‫‫⁭⁪‭‏⁭⁫⁯⁪⁫‫‪‮‫‬‌‎‮‎‭‫⁯⁬⁭⁬‎​‎​‭‭⁯‮<\u002D>([In] uint obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static \u002D \u206B⁫‪‮‭‏‌‍⁭‍⁪‍‏‭⁬‭⁬‎⁭​⁬‏‭⁯‌‫‮‎‮⁪‬⁮‍​⁭‎‌‌‎⁮‮<\u002D>([In] uint obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static void \u202D⁭‭‮‏⁭⁬‎‍‎⁮⁮⁯‭⁯‭⁫⁫‌‏‌⁬‮⁬‬‍⁭⁪‭​⁮‬‬‫⁪‎‬‏⁪‭‮()
  {
    // ISSUE: unable to decompile the method.
  }

  internal static Assembly \u202A‭‪⁭⁮⁯‮⁪‌‫⁫⁬​⁬⁬⁪‍⁪⁪‌‭‭‫‪‏⁮‭‭‎​⁯‏⁮⁬‪‭‪​‪⁫‮(
    [In] object obj0,
    [In] ResolveEventArgs obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  [DllImport("kernel32.dll", EntryPoint = "VirtualProtect")]
  internal static extern bool \u202D⁬‎⁬⁫⁭‎‪⁬‍‌⁭‫⁪‬‮‮‪⁫‍‌‎⁪‍​‎‫‍‎‫⁪⁭‪‌⁭‪‍⁬⁯‬‮(
    [In] IntPtr obj0,
    [In] uint obj1,
    [In] uint obj2,
    [In] ref uint obj3);

  internal static unsafe void \u206D‪‏‮‏⁫⁬⁪⁫⁫‍‎‍⁭‫‪‏‍⁪⁯‬⁫‏‪⁬‭⁬‪⁪⁬‫‪‍‌⁪‌⁫⁫‍‭‮()
  {
    Module module = typeof (\u003CModule\u003E).Module;
label_1:
    int num1 = -1640800356;
    while (true)
    {
      uint num2;
      uint[] numArray1;
      uint[] numArray2;
      uint num3;
      uint* numPtr1;
      int num4;
      uint num5;
      int index;
      ushort num6;
      uint num7;
      uint num8;
      uint num9;
      byte* numPtr2;
      ushort num10;
      uint* numPtr3;
      uint num11;
      bool flag;
      byte* hinstance;
      uint num12;
      uint num13;
      uint num14;
      string fullyQualifiedName;
      uint num15;
      uint* numPtr4;
      uint num16;
      int num17;
      int num18;
      switch ((num2 = (uint) (num1 ^ -1198870218)) % 56U)
      {
        case 0:
          numArray1[11] = numArray1[11] + numArray2[11];
          numArray1[12] = numArray1[12] ^ numArray2[12];
          num1 = (int) num2 * -836277689 ^ -485137279;
          continue;
        case 1:
          numPtr3 = (uint*) (hinstance + (flag ? (int) numPtr1[3] : (int) numPtr1[1]));
          num1 = -475150404;
          continue;
        case 2:
          if (flag)
          {
            num17 = (int) numPtr1[2];
            break;
          }
          num1 = (int) num2 * 1817984471 ^ 671620308;
          continue;
        case 3:
          numArray1[2] = numArray1[2] + numArray2[2];
          numArray1[3] = numArray1[3] ^ numArray2[3];
          num1 = (int) num2 * -727385283 ^ 14631770;
          continue;
        case 4:
          goto label_17;
        case 5:
          num4 = 0;
          num1 = (int) num2 * -1293822490 ^ 1554807623;
          continue;
        case 6:
          num1 = (int) num2 * 2066676744 ^ -864980360;
          continue;
        case 7:
          numArray1[13] = numArray1[13] * numArray2[13];
          numArray1[14] = numArray1[14] + numArray2[14];
          num1 = (int) num2 * -662883533 ^ -1321471389;
          continue;
        case 8:
          numArray1[15] = numArray1[15] ^ numArray2[15];
          num1 = (int) num2 * 1854582859 ^ 1319255209;
          continue;
        case 9:
          numPtr2 = hinstance + (int) *(uint*) (hinstance + 60);
          num1 = (int) num2 * -1416563746 ^ 294749618;
          continue;
        case 10:
          num6 = *(ushort*) (numPtr2 + 6);
          num10 = *(ushort*) (numPtr2 + 20);
          numPtr3 = (uint*) null;
          num1 = (int) num2 * 1660977378 ^ 63255364;
          continue;
        case 11:
          if (fullyQualifiedName.Length <= 0)
          {
            num18 = 0;
            goto label_36;
          }
          else
          {
            num1 = (int) num2 * 1741869595 ^ 155616469;
            continue;
          }
        case 12:
          num8 = num12 >> 3 | num12 << 29;
          num12 = num7 >> 7 | num7 << 25;
          num1 = (int) num2 * -1428361660 ^ -1375934143;
          continue;
        case 13:
          num8 = num7;
          num7 = num9;
          num1 = (int) num2 * 1172412677 ^ -1854105564;
          continue;
        case 14:
          num5 = 0U;
          num1 = (int) num2 * -1245608253 ^ 193195014;
          continue;
        case 15:
          num1 = (int) num2 * -1888616154 ^ -1484367971;
          continue;
        case 16:
          numArray1[(IntPtr) (num14 & 15U)] = (uint) (((int) numArray1[(IntPtr) (num14 & 15U)] ^ (int) *numPtr3++) + 1035675673);
          num1 = (int) num2 * 915387934 ^ -1725596198;
          continue;
        case 17:
          int num19;
          num1 = num19 = num4 < (int) num6 ? -273984574 : (num19 = -1006402807);
          continue;
        case 18:
          fullyQualifiedName = module.FullyQualifiedName;
          num1 = (int) num2 * -1990058848 ^ 529453437;
          continue;
        case 19:
          index = 0;
          num1 = (int) num2 * -176875039 ^ 2016303393;
          continue;
        case 20:
          uint* numPtr5 = numPtr1;
          uint* numPtr6 = (uint*) ((IntPtr) numPtr5 + new IntPtr(4));
          int num20 = (int) *numPtr5;
          uint* numPtr7 = numPtr6;
          numPtr1 = (uint*) ((IntPtr) numPtr7 + new IntPtr(4));
          int num21 = (int) *numPtr7;
          num11 = (uint) (num20 * num21);
          num1 = -1579083265;
          continue;
        case 21:
          num8 = num12;
          num1 = (int) num2 * 207352110 ^ -1697395219;
          continue;
        case 22:
          goto label_3;
        case 23:
          uint num22 = 64;
          \u003CModule\u003E.\u202D⁬‎⁬⁫⁭‎‪⁬‍‌⁭‫⁪‬‮‮‪⁫‍‌‎⁪‍​‎‫‍‎‫⁪⁭‪‌⁭‪‍⁬⁯‬‮((IntPtr) (void*) numPtr3, num5 << 2, num22, ref num22);
          int num23 = num22 != 64U ? -2138366424 : (num23 = -503234269);
          num1 = num23 ^ (int) num2 * -1174757099;
          continue;
        case 24:
          num3 = 0U;
          num1 = (int) num2 * -1680558138 ^ 1124776208;
          continue;
        case 25:
          numArray1[0] = numArray1[0] ^ numArray2[0];
          num1 = (int) num2 * 1962450281 ^ -1055766285;
          continue;
        case 26:
          num18 = fullyQualifiedName[0] == '<' ? 1 : 0;
          goto label_36;
        case 27:
          num8 = 3269223762U;
          num12 = 1281600998U;
          num7 = 3574989155U;
          num1 = (int) num2 * 177185308 ^ -367001937;
          continue;
        case 28:
          numArray1[1] = numArray1[1] * numArray2[1];
          num1 = (int) num2 * -820470416 ^ -1675682083;
          continue;
        case 29:
          uint* numPtr8 = numPtr3;
          int num24 = (int) *numPtr8 ^ (int) numArray1[(IntPtr) (num14 & 15U)];
          *numPtr8 = (uint) num24;
          num1 = -1099916490;
          continue;
        case 30:
          int num25;
          num1 = num25 = num3 < num13 ? -1188427376 : (num25 = -256278240);
          continue;
        case 31:
          numArray1 = new uint[16];
          num1 = (int) num2 * 1659317612 ^ -1687426336;
          continue;
        case 32:
          num13 = numPtr1[2] >> 2;
          num1 = (int) num2 * 617671194 ^ -1988785234;
          continue;
        case 33:
          goto label_1;
        case 34:
          numPtr1 = (uint*) (numPtr2 + 24 + (int) num10);
          num15 = 530304267U;
          num1 = (int) num2 * -1603344042 ^ -21036839;
          continue;
        case 35:
          ++index;
          num1 = (int) num2 * -606637548 ^ 1236042670;
          continue;
        case 36:
          int num26;
          num1 = num26 = index < 16 ? -1488681951 : (num26 = -1516161177);
          continue;
        case 37:
          numArray1[7] = numArray1[7] * numArray2[7];
          num1 = (int) num2 * 2065413541 ^ 1416211967;
          continue;
        case 38:
          numPtr1 += 8;
          ++num4;
          num1 = -441635705;
          continue;
        case 39:
          num7 = num15 >> 11 | num15 << 21;
          num1 = (int) num2 * 155730041 ^ -635220262;
          continue;
        case 40:
          numPtr4 = (uint*) (hinstance + (flag ? (int) numPtr1[3] : (int) numPtr1[1]));
          num1 = -571969386;
          continue;
        case 41:
          int num27 = num11 == 3868529568U ? 1089629671 : (num27 = 1735507043);
          num1 = num27 ^ (int) num2 * 770982648;
          continue;
        case 42:
          numArray2 = new uint[16];
          num1 = (int) num2 * 926412772 ^ 444083693;
          continue;
        case 43:
          ++num3;
          num1 = (int) num2 * -1164074180 ^ -970934596;
          continue;
        case 44:
          num17 = (int) *numPtr1;
          break;
        case 45:
          num14 = 0U;
          num16 = 0U;
          num1 = -819994900;
          continue;
        case 46:
          hinstance = (byte*) (void*) Marshal.GetHINSTANCE(module);
          num1 = (int) num2 * -584597292 ^ 1480055295;
          continue;
        case 47:
          numArray1[9] = numArray1[9] ^ numArray2[9];
          numArray1[10] = numArray1[10] * numArray2[10];
          num1 = (int) num2 * -1157578569 ^ 673874431;
          continue;
        case 48:
          numArray1[8] = numArray1[8] + numArray2[8];
          num1 = (int) num2 * 1754778539 ^ -726983047;
          continue;
        case 49:
          numArray1[6] = numArray1[6] ^ numArray2[6];
          num1 = (int) num2 * -1435609859 ^ -981677674;
          continue;
        case 50:
          int num28;
          num1 = num28 = num16 >= num5 ? -510522102 : (num28 = -469264501);
          continue;
        case 51:
          numArray1[4] = numArray1[4] * numArray2[4];
          numArray1[5] = numArray1[5] + numArray2[5];
          num1 = (int) num2 * -1083998336 ^ 859284927;
          continue;
        case 52:
          ++num14;
          ++num16;
          num1 = (int) num2 * 1638064163 ^ -552870232;
          continue;
        case 53:
          int num29;
          num1 = num29 = num11 != 0U ? -1851886810 : (num29 = -256278240);
          continue;
        case 54:
          num9 = (uint) (((int) num15 ^ (int) *numPtr4++) + (int) num8 + (int) num12 * (int) num7);
          num15 = num8;
          num1 = -1240842085;
          continue;
        case 55:
          numArray1[index] = num7;
          numArray2[index] = num8;
          num15 = num8 >> 5 | num8 << 27;
          num1 = -909330734;
          continue;
        default:
          goto label_64;
      }
      num5 = (uint) (num17 >>> 2);
      num1 = -256278240;
      continue;
label_36:
      flag = num18 != 0;
      num1 = -1025421816;
    }
label_17:
    return;
label_3:
    return;
label_64:;
  }

  internal struct \u202B‪⁮⁫⁭‏‭‬‪‭⁪⁪⁭‪‌⁮​‎‎‍‬⁬‫‮⁯‮⁯‍⁫⁭‬⁪‍‌⁯‎‪‭⁬‮‮
  {
    internal uint \u202C‌‮⁪‏⁯‎‬‫⁫​‮‬‍‮⁮⁯​⁪⁬‫⁬‌⁪‮⁬⁯⁫⁭‬‫‎​‏⁪⁭‌‮⁫‎‮;

    internal void \u200C‌‪‎‮‏‬‬‎​‎‬‬‏‬⁫⁬⁭‪‍‏⁭‪‭‎‍​​⁫‌⁭​⁪‫‫⁪​⁭‭⁫‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal uint \u206A‎‭‫⁫⁯⁬‮‍⁭‭⁪‪⁯‪⁫‌‬⁬‫‭⁮⁭⁮⁫‮​‬‫‮‎‬⁫‌⁭‍‪‭⁯‮(
      [In] \u003CModule\u003E.\u200B​⁬‎‎⁯‏⁪‍⁪⁪‏‬‌​⁮‎​⁬‌⁮⁫⁭⁪‬⁮⁬⁮‪⁪⁬‬⁭‪‫‏⁯⁭‍‬‮ obj0)
    {
      // ISSUE: unable to decompile the method.
    }
  }

  internal struct \u206E‮⁮‭⁭⁮‪​‮⁯⁪⁫‌⁮‎⁫⁮​‎⁯‏‌⁮⁭‍‌‍‌‮‬‪‌‍‮‫⁮‍‫‏⁮‮
  {
    internal readonly \u003CModule\u003E.\u202B‪⁮⁫⁭‏‭‬‪‭⁪⁪⁭‪‌⁮​‎‎‍‬⁬‫‮⁯‮⁯‍⁫⁭‬⁪‍‌⁯‎‪‭⁬‮‮[] \u200F⁪⁯​⁬‬⁯⁮‍⁯⁬‮⁮⁮⁫⁯⁯‭⁫‪‫⁭⁪‫⁯​⁫‬‏‭‭⁪⁫⁮‎‫⁪‎⁬⁬‮;
    internal readonly int \u200D‎‮⁬‫⁪‭‍⁪‫⁯​⁫‫⁯‎‎‍⁫‮⁭​‮‏⁯​‮⁮‎‬⁪‪⁬‎‬⁯‎‭‏⁪‮;

    internal \u206E‮⁮‭⁭⁮‪​‮⁯⁪⁫‌⁮‎⁫⁮​‎⁯‏‌⁮⁭‍‌‍‌‮‬‪‌‍‮‫⁮‍‫‏⁮‮([In] int obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u206F⁬⁭‎‫⁯⁮‍‌⁪‪‮‪‍‌‎⁯⁬‬⁪⁪⁫‮‏‌⁯⁮⁬‏⁪‪‌‬⁮⁪‪‬‭‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal uint \u200E​⁬⁫⁭‬‬‍‬⁬‪‍⁯‎‫‏‮⁫​‬‫⁪‌‎‍‬‫⁬⁬‬‭‫‎‪⁮⁭‪‍‪⁮‮(
      [In] \u003CModule\u003E.\u200B​⁬‎‎⁯‏⁪‍⁪⁪‏‬‌​⁮‎​⁬‌⁮⁫⁭⁪‬⁮⁬⁮‪⁪⁬‬⁭‪‫‏⁯⁭‍‬‮ obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal uint \u202B‭‬⁮‬‏‌‭‭⁪​‏‎‫⁭‌‮⁫​‭⁯‮‪⁭‮⁫‌‭​‬⁫​‮⁯‬⁯‏‪‪‍‮(
      [In] \u003CModule\u003E.\u200B​⁬‎‎⁯‏⁪‍⁪⁪‏‬‌​⁮‎​⁬‌⁮⁫⁭⁪‬⁮⁬⁮‪⁪⁬‬⁭‪‫‏⁯⁭‍‬‮ obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal static uint \u202B‮‎‬⁮‭⁭‍⁪​‌​⁫‪‪‭‎⁯‫⁬⁫‏⁭‬⁯‮⁪​‭⁮⁬‪‏‎‍‌⁬‏‌⁬‮(
      [In] \u003CModule\u003E.\u202B‪⁮⁫⁭‏‭‬‪‭⁪⁪⁭‪‌⁮​‎‎‍‬⁬‫‮⁯‮⁯‍⁫⁭‬⁪‍‌⁯‎‪‭⁬‮‮[] obj0,
      [In] uint obj1,
      [In] \u003CModule\u003E.\u200B​⁬‎‎⁯‏⁪‍⁪⁪‏‬‌​⁮‎​⁬‌⁮⁫⁭⁪‬⁮⁬⁮‪⁪⁬‬⁭‪‫‏⁯⁭‍‬‮ obj2,
      [In] int obj3)
    {
      // ISSUE: unable to decompile the method.
    }
  }

  internal class \u200B​⁬‎‎⁯‏⁪‍⁪⁪‏‬‌​⁮‎​⁬‌⁮⁫⁭⁪‬⁮⁬⁮‪⁪⁬‬⁭‪‫‏⁯⁭‍‬‮
  {
    internal uint \u202B‏‏⁪‌⁭‍⁯⁬‬‎⁬‍‭‌⁬‎‌‮⁬​⁪‎‭‬‪⁯‭⁬‪⁭⁬⁯‏‌‪‭‎‫‮;
    internal uint \u202D⁮‏⁮⁭‏‌​‪‎⁬‭‎⁯⁫⁬‍⁭‍‫⁭‏‍⁯‬‪‌‮‏‭‌⁫‌⁮⁪‭‬‮⁯‏‮;
    internal Stream \u202A⁮‏‫⁮‫‮‌⁭⁯⁪⁬‎‫⁫‫‍⁪⁬⁮⁬⁭⁫‏⁬​‪⁯⁭‬‬⁪‏​⁮‬‮‌⁯⁫‮;

    internal void \u200C‎⁫‍⁬‍⁭‬‌‬⁫⁫⁬⁪​‪⁯‮‮⁮⁬‌⁮⁬⁬‪‫‎⁪‪‬‌‭​​‬⁮‪‪‫‮([In] Stream obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u202D⁬⁮⁫‏‌‎‮‬‮‌‌⁫‍​‮‭‎⁫⁯‬‮⁯⁮‏‌‌‮‭‌‎⁮‍‏⁭⁬‏⁭‭‌‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200E‮​​‍‬‍​⁫‏‏‏‮⁫‫‎⁭⁭⁭‬‪‫⁫⁮‭⁮‍‌‪⁫‭⁬‬‬‎⁫‍‬‍⁫‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal uint \u206D⁪​‍‬‭‬⁪‎⁬⁭‍⁪⁬‎‫‪⁪​​⁭​⁯‪‏‭⁪​⁭⁬⁯⁪⁯⁯⁪‎⁫‍‎‎‮([In] int obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal \u200B​⁬‎‎⁯‏⁪‍⁪⁪‏‬‌​⁮‎​⁬‌⁮⁫⁭⁪‬⁮⁬⁮‪⁪⁬‬⁭‪‫‏⁯⁭‍‬‮()
    {
      // ISSUE: unable to decompile the method.
    }
  }

  internal class \u202C‮⁭‍​‎⁯⁮‭‍⁮⁯‏‫‬‍⁮‌‭‎‭‭‏​‪‭‫‬‬⁬​⁭​‎⁭⁮‫‎‬⁭‮
  {
    internal readonly \u003CModule\u003E.\u202B‪⁮⁫⁭‏‭‬‪‭⁪⁪⁭‪‌⁮​‎‎‍‬⁬‫‮⁯‮⁯‍⁫⁭‬⁪‍‌⁯‎‪‭⁬‮‮[] \u206C‮‮‍⁫‮⁯⁮‎‮⁬‭‫‮⁯‫⁯‬‪‮‭‫⁫‍⁪⁪‌‫⁮⁪‮‫‌‌​‏⁪‌‬‮;
    internal readonly \u003CModule\u003E.\u202B‪⁮⁫⁭‏‭‬‪‭⁪⁪⁭‪‌⁮​‎‎‍‬⁬‫‮⁯‮⁯‍⁫⁭‬⁪‍‌⁯‎‪‭⁬‮‮[] \u200F⁯‌‪⁭‭​‮⁪⁮‮⁮​‭‪⁬⁯⁪‪‭⁫‌​‭‬​⁭‎⁯⁯‭‬⁫⁭‪‍⁬‎⁮‪‮;
    internal readonly \u003CModule\u003E.\u202B‪⁮⁫⁭‏‭‬‪‭⁪⁪⁭‪‌⁮​‎‎‍‬⁬‫‮⁯‮⁯‍⁫⁭‬⁪‍‌⁯‎‪‭⁬‮‮[] \u206F‍‬⁮‭‭​‌‭‏‬‭‮⁬‬‪‏​⁭⁫​‍⁫‭⁭⁬⁯⁫⁪⁪‪⁪‫‏‏⁯⁯‪⁫‮‮;
    internal readonly \u003CModule\u003E.\u202B‪⁮⁫⁭‏‭‬‪‭⁪⁪⁭‪‌⁮​‎‎‍‬⁬‫‮⁯‮⁯‍⁫⁭‬⁪‍‌⁯‎‪‭⁬‮‮[] \u206F‬⁮‫⁭‫⁬‍⁬‭​‍⁯⁫‮⁯⁮‬‭⁯‎‍⁫⁭‬‍‮‭‍‏‎⁫⁫‪⁮‌‮⁪⁮‭‮;
    internal readonly \u003CModule\u003E.\u202B‪⁮⁫⁭‏‭‬‪‭⁪⁪⁭‪‌⁮​‎‎‍‬⁬‫‮⁯‮⁯‍⁫⁭‬⁪‍‌⁯‎‪‭⁬‮‮[] \u200D‪⁬⁬‎‍⁮‫‪‎⁬‌‎‬‏‍‬⁯​⁭​‍⁮​​‮‎⁯‭‌‪⁯⁭‬⁯‏‎‍⁪‭‮;
    internal readonly \u003CModule\u003E.\u202B‪⁮⁫⁭‏‭‬‪‭⁪⁪⁭‪‌⁮​‎‎‍‬⁬‫‮⁯‮⁯‍⁫⁭‬⁪‍‌⁯‎‪‭⁬‮‮[] \u206C⁬⁬‪⁬⁪‬‏‮‫‮​⁪⁪⁫‌‮​⁬‪‬‌‫‬‭‫‎⁭‬‎‏‍‌‪⁭‫⁮‮‍‏‮;
    internal readonly \u003CModule\u003E.\u202C‮⁭‍​‎⁯⁮‭‍⁮⁯‏‫‬‍⁮‌‭‎‭‭‏​‪‭‫‬‬⁬​⁭​‎⁭⁮‫‎‬⁭‮.\u200C‍‬​⁬⁫‫‪‪‏‭‍‮⁫‌⁬‬​‍‮‮⁪‬⁭⁮‭⁯⁬‮⁪⁮⁮‏‫⁫‬‮​‬‬‮ \u202A‏‬‏‮‭‪‮​​‭‎‍⁯⁭‍⁫‌⁮​‏⁪​‬‬‎⁬‌⁮‌⁮‏‏⁮⁯​⁬⁮⁮‏‮;
    internal readonly \u003CModule\u003E.\u202C‮⁭‍​‎⁯⁮‭‍⁮⁯‏‫‬‍⁮‌‭‎‭‭‏​‪‭‫‬‬⁬​⁭​‎⁭⁮‫‎‬⁭‮.\u206A‫‎‮‮⁮⁭‬⁫⁬‮⁪‬⁯‎‏‫​‌‏⁫⁫‌⁪⁫⁯‫‬‏‍‪⁪‎‏‫‏‏⁯⁮⁫‮ \u202E‍⁮‌⁮‌⁫⁭⁭​‫‏⁯‬⁪⁭‮‌⁯⁯‎‌⁯​​‌‏⁫‎‭‪‎⁫⁫‎​‌⁫‌‎‮;
    internal readonly \u003CModule\u003E.\u200B‍‬⁭⁫‫​⁮‮⁬⁭⁯‪⁯⁯‬⁭⁮⁪‭‪⁪⁪‏⁭‪‫‏‬‬‭‌‍​⁮‫​‮‌‫‮ \u206F⁬⁫⁬‬‌‍​⁪⁭⁮‬⁪⁫‪⁯‮⁬‏‌‮⁯‮‬⁪⁮‫‫‏⁭⁯‪⁫‬‫‏​‍‏‪‮;
    internal readonly \u003CModule\u003E.\u202B‪⁮⁫⁭‏‭‬‪‭⁪⁪⁭‪‌⁮​‎‎‍‬⁬‫‮⁯‮⁯‍⁫⁭‬⁪‍‌⁯‎‪‭⁬‮‮[] \u206A‍⁬‬‏‍‪⁮‮⁫⁭⁫‪⁯⁮‫⁯‎‭​‪‍‭‌​‏‎⁬‮⁯⁬⁬‪‌⁯​‎⁬​‍‮;
    internal readonly \u003CModule\u003E.\u206E‮⁮‭⁭⁮‪​‮⁯⁪⁫‌⁮‎⁫⁮​‎⁯‏‌⁮⁭‍‌‍‌‮‬‪‌‍‮‫⁮‍‫‏⁮‮[] \u206E​⁮‌‍⁯‮‭⁯‏⁯⁯⁭‭‌⁪‭‫⁪⁭⁮‌‫‌⁯⁬⁫⁬‍‌‫‏‭‎⁮⁪​‭‏‏‮;
    internal readonly \u003CModule\u003E.\u200B​⁬‎‎⁯‏⁪‍⁪⁪‏‬‌​⁮‎​⁬‌⁮⁫⁭⁪‬⁮⁬⁮‪⁪⁬‬⁭‪‫‏⁯⁭‍‬‮ \u200E‭⁮‪‪⁬⁯​​⁪‎⁫‏⁬​‌​‮‏​‪‬⁪⁭‌⁬‭⁫‍‫⁫‎‌‭⁬⁫⁫​‫⁭‮;
    internal readonly \u003CModule\u003E.\u202C‮⁭‍​‎⁯⁮‭‍⁮⁯‏‫‬‍⁮‌‭‎‭‭‏​‪‭‫‬‬⁬​⁭​‎⁭⁮‫‎‬⁭‮.\u200C‍‬​⁬⁫‫‪‪‏‭‍‮⁫‌⁬‬​‍‮‮⁪‬⁭⁮‭⁯⁬‮⁪⁮⁮‏‫⁫‬‮​‬‬‮ \u206A‍‏⁭‍⁮‏‍‭‏⁪⁬⁫‏‏⁫​‌‮‮‍‬⁪‍⁬‫‭‭‭‮‌​‏‎​‏⁯⁮​‪‮;
    internal bool \u206D‌​‪⁬‏‪‮⁮‭⁮‫‍‬‌⁭‍‎⁬‪‪‍‭⁯‏‏‪‏‬⁭‎⁮​‎‍‮‏‎⁭‏‮;
    internal uint \u206D‭⁬‏‎⁫⁮​‏⁬⁭⁫‭‭‏‏⁪‮‌‬‌⁮⁭‭‪⁫‪‏⁮‪‭‭⁯‏‍⁬‌⁬​⁮‮;
    internal uint \u200B⁬‍⁯‪⁮⁮‎‌⁭⁫‭‎⁮⁭⁬‎⁮⁭‫⁪⁪​⁮‪‬⁬‭‌⁮⁮‬‎⁮⁭‪⁫⁮‪‪‮;
    internal \u003CModule\u003E.\u206E‮⁮‭⁭⁮‪​‮⁯⁪⁫‌⁮‎⁫⁮​‎⁯‏‌⁮⁭‍‌‍‌‮‬‪‌‍‮‫⁮‍‫‏⁮‮ \u202D⁯⁪​​‪‍‮⁯⁮⁭‎‫⁫‬‌⁮‭⁮⁮⁮‏⁪⁮⁬⁭⁫‬⁪‪⁯‎‭​‌‮⁯‎⁬⁮‮;
    internal uint \u206C⁮‬⁫⁬⁫‮‭⁬​⁫‌⁭‏⁬‫⁬⁪‎‭‪‏‌‎⁪⁪‭‬‌‬⁯‪‪‬​⁮‭⁮⁫⁫‮;

    internal \u202C‮⁭‍​‎⁯⁮‭‍⁮⁯‏‫‬‍⁮‌‭‎‭‭‏​‪‭‫‬‬⁬​⁭​‎⁭⁮‫‎‬⁭‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u206D‭‍‪‏⁯​‫‭⁬⁯‮​⁫‪⁬⁫‮‪⁪‪‍⁪⁪‎‬‭⁮‎⁭‪⁭⁪‎⁮​‮⁭⁭‏‮([In] uint obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u202A‮‮‮⁬‌‌⁪‬‍‏‏⁯⁬‪‬⁪‬‮‍​⁯‬⁭​⁭⁮‫⁬⁭⁯‭‏‭⁬​⁫‮‮‏‮([In] int obj0, [In] int obj1)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200F‪‏‫⁮‫‍‫‬⁫‌⁫‮‌⁭‬‬‍​‮‫⁭​⁪‬‭⁭⁫‌⁫⁯‪‫‏⁬⁮⁬​‌‪‮([In] int obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u206F⁫‪‫‭‬⁯‌‬‏‫⁯‬‎⁮⁯‏⁪‬‎‬⁭‎‌‪‭‫‌⁯‍⁬⁭⁯⁮⁪‌‌⁫⁭‌‮([In] Stream obj0, [In] Stream obj1)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u206E‍⁬⁫​⁬‌⁮‌⁬‫⁬​​‬‌‍⁮⁭⁮⁯‮‭⁫⁪‫​‍⁫‮‫‎⁯‮‫‏‭⁬‬⁪‮(
      [In] Stream obj0,
      [In] Stream obj1,
      [In] long obj2,
      [In] long obj3)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u202E‭‬‌‪​‮‪⁫‌‬‍⁫⁪‎‎​‫⁮⁫‍‍​⁯⁭‎‎​‌⁫⁪⁪⁫⁪⁪‫⁪‬⁭⁫‮([In] byte[] obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal static uint \u206A‏‎⁭‮⁫⁪‍‮⁬‌​‌​​⁯​‌⁬‍‌‍‏‫‌‭⁮⁫​‎​‮‌​‬‮⁯⁯⁫‭‮([In] uint obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal class \u200C‍‬​⁬⁫‫‪‪‏‭‍‮⁫‌⁬‬​‍‮‮⁪‬⁭⁮‭⁯⁬‮⁪⁮⁮‏‫⁫‬‮​‬‬‮
    {
      internal readonly \u003CModule\u003E.\u206E‮⁮‭⁭⁮‪​‮⁯⁪⁫‌⁮‎⁫⁮​‎⁯‏‌⁮⁭‍‌‍‌‮‬‪‌‍‮‫⁮‍‫‏⁮‮[] \u202C‍​‎⁬⁫‌‌⁪⁫‎‪​‭‭‎‫⁪⁯⁮‭⁬‫‍‏​‮⁮⁪‫⁫⁮⁯‏⁭⁬‏‮‭‌‮;
      internal readonly \u003CModule\u003E.\u206E‮⁮‭⁭⁮‪​‮⁯⁪⁫‌⁮‎⁫⁮​‎⁯‏‌⁮⁭‍‌‍‌‮‬‪‌‍‮‫⁮‍‫‏⁮‮[] \u202E⁫‏‭‎⁫⁬‏‫‭⁫⁫⁬‪⁯‌‪⁭‍⁭⁯‏‫‫‮‮⁬‬‍⁬​‫‬‌⁫‪⁬⁯‌⁭‮;
      internal \u003CModule\u003E.\u202B‪⁮⁫⁭‏‭‬‪‭⁪⁪⁭‪‌⁮​‎‎‍‬⁬‫‮⁯‮⁯‍⁫⁭‬⁪‍‌⁯‎‪‭⁬‮‮ \u202B⁯‫‫‍‭⁯‍‏⁪‍⁪‌⁭⁬⁪⁬‮‏‮⁯‌⁫‏‎‬⁪‎‌⁪‭‌⁯⁬‬​‍⁪‮‭‮;
      internal \u003CModule\u003E.\u202B‪⁮⁫⁭‏‭‬‪‭⁪⁪⁭‪‌⁮​‎‎‍‬⁬‫‮⁯‮⁯‍⁫⁭‬⁪‍‌⁯‎‪‭⁬‮‮ \u200B‮⁭‪‎‍⁭‭‮⁮⁫​⁭‬⁬⁮‎‏‫​‭‮⁯‏⁬⁫‏‪‍​‎⁭‫‮‌⁪‭⁮‬⁫‮;
      internal \u003CModule\u003E.\u206E‮⁮‭⁭⁮‪​‮⁯⁪⁫‌⁮‎⁫⁮​‎⁯‏‌⁮⁭‍‌‍‌‮‬‪‌‍‮‫⁮‍‫‏⁮‮ \u202D‎‮‬⁮⁫‎⁯⁫⁭​⁯⁫⁭‏⁮⁭​⁬⁫‫‫⁫‌⁬⁮‌‮‌‎‏​‮‮​‮⁭‌‬⁭‮;
      internal uint \u202B‭‬⁬‮‎‍‍‏‎‎⁮‮‫⁬⁪​‌‫⁯​‮⁯⁪⁭‎‏⁭⁯​‌‭⁭⁮‫⁪‮‭⁭‍‮;

      internal void \u200F‪​⁮⁬⁯‮⁯‍⁬‍⁫‫‪⁭⁯‌‪⁬‏​⁪⁫‬⁬‪‫‪‌‫⁪⁮‬⁯‌⁪‎⁭‏‬‮([In] uint obj0)
      {
        // ISSUE: unable to decompile the method.
      }

      internal void \u202D‌‮‎‫‮‪‎⁭⁪‍⁮‮⁬​‪​‍‍⁮‬⁪⁯‫⁯⁯‪⁬⁭‬⁯‪⁯‫‏‪​‮‏‭‮()
      {
        // ISSUE: unable to decompile the method.
      }

      internal uint \u206C⁯⁭‍‮‪‪‍‌‮‪‬⁬⁯⁪​​‌⁫⁫⁯⁪​⁬‍⁫‪⁯⁮‏⁯‍‭‭⁫⁮‬⁪‍‬‮(
        [In] \u003CModule\u003E.\u200B​⁬‎‎⁯‏⁪‍⁪⁪‏‬‌​⁮‎​⁬‌⁮⁫⁭⁪‬⁮⁬⁮‪⁪⁬‬⁭‪‫‏⁯⁭‍‬‮ obj0,
        [In] uint obj1)
      {
        // ISSUE: unable to decompile the method.
      }

      internal \u200C‍‬​⁬⁫‫‪‪‏‭‍‮⁫‌⁬‬​‍‮‮⁪‬⁭⁮‭⁯⁬‮⁪⁮⁮‏‫⁫‬‮​‬‬‮()
      {
        // ISSUE: unable to decompile the method.
      }
    }

    internal class \u206A‫‎‮‮⁮⁭‬⁫⁬‮⁪‬⁯‎‏‫​‌‏⁫⁫‌⁪⁫⁯‫‬‏‍‪⁪‎‏‫‏‏⁯⁮⁫‮
    {
      internal \u003CModule\u003E.\u202C‮⁭‍​‎⁯⁮‭‍⁮⁯‏‫‬‍⁮‌‭‎‭‭‏​‪‭‫‬‬⁬​⁭​‎⁭⁮‫‎‬⁭‮.\u206A‫‎‮‮⁮⁭‬⁫⁬‮⁪‬⁯‎‏‫​‌‏⁫⁫‌⁪⁫⁯‫‬‏‍‪⁪‎‏‫‏‏⁯⁮⁫‮.\u206E‍⁯⁫​‮‌⁯‌⁮‎⁫‏‎‍⁯⁫⁮⁫‏‍‌‬‏‬‪‮‬⁮‍‭‌‮‬‬‎⁭‭‌‪‮[] \u202C‏⁭‍‎⁮⁬‎‎‎⁭‏‮‬‪‎‍‫‏‍​​⁫‭⁬⁯⁫‬‏‪‎‏⁮‮‭‮​⁬⁫‮;
      internal int \u202E‬‏⁫‪‪⁪‪⁮‎⁪⁪‌⁮⁪‎⁬‌⁬‎‬‪‌⁬‏⁯⁮​‫‌⁮‮⁮​‏‏‮⁮⁬‏‮;
      internal int \u200E‬⁭‌‌‮‏‫⁫⁯⁮⁮⁯⁮⁬⁯‭​‪‪⁫‭‮⁮‎‏‍‫‪​‫‏⁭⁯‌⁪⁯‭‎‭‮;
      internal uint \u200B‫‭⁬‏⁮‏‌​⁭‬⁭⁪‏‏⁮⁬‏​⁬⁪‮‮⁬‍⁭‌​⁯⁬‫⁪⁫‫‬⁭‬‍‌‪‮;

      internal void \u202A‪⁮⁫⁪‌⁬⁮⁯‪‍⁯⁭⁪‎⁭‮‫‫⁫​‫‭⁫‭⁬⁫‏‎‎‭‬‏⁫‫‭​‭⁯⁯‮([In] int obj0, [In] int obj1)
      {
        // ISSUE: unable to decompile the method.
      }

      internal void \u206E‍​⁫⁬⁮⁪⁮⁯⁪⁯‍⁮‪‭⁭⁯‬‌‌​‍‮‏​‎⁯‬⁬‮⁯‪⁬‌⁮‍‪‌‪⁬‮()
      {
        // ISSUE: unable to decompile the method.
      }

      internal uint \u206D‭​​‎‪⁭⁫‬‪⁬⁪‍‬‫‌‌‌‬⁬‫⁬‬⁬‏‭‮‬​⁪‌‫‭⁪‪⁭‪‌⁭‎‮([In] uint obj0, [In] byte obj1)
      {
        // ISSUE: unable to decompile the method.
      }

      internal byte \u200C⁯⁭​‭⁬​‎‬‌‭⁪‏⁬‭⁭‫‪⁫‫⁫⁯‎‫‏⁮‎​‏⁭⁬‬‮‮‬‪‮⁭⁭⁬‮(
        [In] \u003CModule\u003E.\u200B​⁬‎‎⁯‏⁪‍⁪⁪‏‬‌​⁮‎​⁬‌⁮⁫⁭⁪‬⁮⁬⁮‪⁪⁬‬⁭‪‫‏⁯⁭‍‬‮ obj0,
        [In] uint obj1,
        [In] byte obj2)
      {
        // ISSUE: unable to decompile the method.
      }

      internal byte \u200F‫‌‏⁪‍‬⁪‎‌‍‮‍⁭‪⁫‪​⁯​⁫⁯‎‌​⁯⁫‍​⁮‪​​‬⁫⁭‮‪⁬⁪‮(
        [In] \u003CModule\u003E.\u200B​⁬‎‎⁯‏⁪‍⁪⁪‏‬‌​⁮‎​⁬‌⁮⁫⁭⁪‬⁮⁬⁮‪⁪⁬‬⁭‪‫‏⁯⁭‍‬‮ obj0,
        [In] uint obj1,
        [In] byte obj2,
        [In] byte obj3)
      {
        // ISSUE: unable to decompile the method.
      }

      internal \u206A‫‎‮‮⁮⁭‬⁫⁬‮⁪‬⁯‎‏‫​‌‏⁫⁫‌⁪⁫⁯‫‬‏‍‪⁪‎‏‫‏‏⁯⁮⁫‮()
      {
        // ISSUE: unable to decompile the method.
      }

      internal struct \u206E‍⁯⁫​‮‌⁯‌⁮‎⁫‏‎‍⁯⁫⁮⁫‏‍‌‬‏‬‪‮‬⁮‍‭‌‮‬‬‎⁭‭‌‪‮
      {
        internal \u003CModule\u003E.\u202B‪⁮⁫⁭‏‭‬‪‭⁪⁪⁭‪‌⁮​‎‎‍‬⁬‫‮⁯‮⁯‍⁫⁭‬⁪‍‌⁯‎‪‭⁬‮‮[] \u206E‌⁭‍‪‫​⁮⁭‍⁬⁫‍‬⁫‫‍‍‌‪‎‫‎‌‫​​‮‎‮⁪⁫‎⁫‏‎‬‍⁯‌‮;

        internal void \u206C⁯‍‌‎‌‪​‫​‮‮⁮⁫​‌⁫‭⁭‌⁯‪‌‮‎​‍⁫⁭⁮‌⁪⁫‎⁯‎‪‮‎‮()
        {
          // ISSUE: unable to decompile the method.
        }

        internal void \u206E‪‪‏⁬⁯‬⁪⁭⁯‬‮‬‌‌⁪‌​‎‫‎‪⁬‍‎‮‪​⁭‭‎‮‎‫‭​‏⁪⁫‏‮()
        {
          // ISSUE: unable to decompile the method.
        }

        internal byte \u202D‏‌​⁯‌⁮‭‭‎⁪‏‫⁭‍​⁭​‏‍⁪‬⁫⁭⁬⁪‪‫‬⁬‌‏‏‎⁯‍‭‭‎‭‮(
          [In] \u003CModule\u003E.\u200B​⁬‎‎⁯‏⁪‍⁪⁪‏‬‌​⁮‎​⁬‌⁮⁫⁭⁪‬⁮⁬⁮‪⁪⁬‬⁭‪‫‏⁯⁭‍‬‮ obj0)
        {
          // ISSUE: unable to decompile the method.
        }

        internal byte \u202D‭​⁫⁪‌‍⁯⁪⁯⁯‍‍‬⁫​⁬⁬⁭‬⁮⁬⁭⁬⁮⁫‌‌​⁭‏‬‭‎‎‌‮‎⁯‍‮(
          [In] \u003CModule\u003E.\u200B​⁬‎‎⁯‏⁪‍⁪⁪‏‬‌​⁮‎​⁬‌⁮⁫⁭⁪‬⁮⁬⁮‪⁪⁬‬⁭‪‫‏⁯⁭‍‬‮ obj0,
          [In] byte obj1)
        {
          // ISSUE: unable to decompile the method.
        }
      }
    }
  }

  internal class \u200B‍‬⁭⁫‫​⁮‮⁬⁭⁯‪⁯⁯‬⁭⁮⁪‭‪⁪⁪‏⁭‪‫‏‬‬‭‌‍​⁮‫​‮‌‫‮
  {
    internal byte[] \u206C​‮⁭⁯‭⁫⁮⁭‬‬⁬‪‪​‪‪‎​⁪⁮​‫⁬⁪‏⁪⁫‭‎⁫‬⁮⁭‎⁯‪‪‏⁫‮;
    internal uint \u200C‪‬‬⁫⁪⁪⁭⁮⁫⁮‍‬‌​‭⁪‭‪‎‪‫⁭‎‏‬‍⁬‬⁬⁯‍‍‎‌‏‫‫⁭‮;
    internal Stream \u206F​⁯⁪​⁫⁯⁭‎⁭‎​⁮‮‍⁯⁪⁫⁯‮⁬‎⁮‮⁭‭⁫​⁫⁯‍‌​⁫‍‭⁮​‏⁯‮;
    internal uint \u206D‎‎⁬‌‌⁭‮‍‫‮‍⁯⁫‬‬‭‮‮⁮⁬‌‌⁫‏‫‭‬‏‬‫​⁪⁪⁫‫‭‎‬‪‮;
    internal uint \u206B⁫⁪⁬‍‮⁭‮‍‮⁪⁮‍‬‍⁯‎‪⁪‫‮⁮‬⁯‌‍​⁬‭⁫‭​‭‍‎⁮‎⁬⁬⁭‮;

    internal void \u202C‭‪‍⁭‎‫‏‌⁯‮‪‏⁯‬‫​‏⁭‮‪⁯‬⁬‭⁫⁬‭‎‮‫‭⁮‍‍‌⁪⁪‍⁯‮([In] uint obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200F‮‪⁭‍‫‮⁯⁭‮‪‍‏⁪​⁫‪‬​⁮⁬⁯⁪‭‮⁫‪​⁯‎‎‮‏⁮‍⁮‍‬‌‮‮([In] Stream obj0, [In] bool obj1)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u206F⁯‌‍⁮‪‫‬‮⁬‪‏‎⁫⁪⁭‮⁮⁭⁬​‏⁭⁪‍‬⁮‏‮‫⁬‮‭‎⁫⁮⁯⁯⁭‎‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u206F⁫⁪‬​‍⁮‌⁮‮‎‍‮⁫‏​‪​⁪‭⁬‮​⁯‌⁪⁮‪‭‌⁬‪​⁮⁫‏‪⁫⁭⁬‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u206E‮‬⁫⁯‭‭‫⁭⁮‍‪‏​‬‎‍⁮‮‭‏‏‫‌⁫‮‌⁮⁫⁮⁬‏‭‌‮‫‭‪‎‮([In] uint obj0, [In] uint obj1)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u206B⁫‪⁯⁬⁫⁪‎⁭‫‪⁭‪‬⁭⁮⁯⁫⁭‭⁮‎‫‪⁮⁭​‮⁫‎‌‪⁮‎‎⁫⁯‫‌‍‮([In] byte obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal byte \u206B⁪‭⁮⁬‪‭‬‎‌‫⁫⁪⁫‮‫​‬​‍​‮‮‪‏⁯‎‏⁪‎⁪⁯‫‍‬‭‮⁯‬⁭‮([In] uint obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal \u200B‍‬⁭⁫‫​⁮‮⁬⁭⁯‪⁯⁯‬⁭⁮⁪‭‪⁪⁪‏⁭‪‫‏‬‬‭‌‍​⁮‫​‮‌‫‮()
    {
      // ISSUE: unable to decompile the method.
    }
  }

  internal struct \u202E‭‮‫‎⁪​‍⁪⁮⁮‎⁭⁫‫‎⁭​⁭‏‮⁫‎‪‮⁭⁮⁫‪‎‎‭‫​‫‎‌‪‫‏‮
  {
    internal uint \u202C⁬‭‌⁬‮​⁭⁪‍​‭⁭‎⁯⁭‪‮⁭⁬‪⁮⁮‎​⁮‭‌⁪⁭‎‏‫⁯⁯⁭‎⁮‏⁯‮;

    internal void \u206D​‮⁭⁪⁯‪​‏‎⁪⁭​‍‎‫‮‌‪‏⁮‫‮‏‍⁮⁭⁪‍‮⁯‫⁬⁪⁬⁭⁮⁮‌‮‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u202D‌⁪​⁪‎‬⁫⁭‫⁭‌⁬​‮‪⁬⁭‏⁪⁫⁯‏⁮‮‮‏‭⁪‎‌‎‭⁪‮‮‪‌⁯‪‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u202C⁫‎‭⁯‭​​⁪‪⁫⁮⁫‭⁭‮⁭‍⁮‪‫‭‍‬⁭‪‮⁮‎‎⁯‎⁭‬⁯‏‎‬‎‪‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u206E⁪‎⁮⁫​‮⁮⁯⁫‫​⁬⁮‍‫⁪⁪‮‌⁮‭⁪⁯‪‎‬‌‮‭‎‬​​‍⁮‬​⁭‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200C​⁪‫‪⁬⁬⁫⁫‮‌⁪⁭‍‌‫⁬‮‫⁯‍⁯‎⁬‍‭‬⁫‪‫⁪⁪⁭‭‌⁮‮‎⁮⁯‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal bool \u202B‏‫‎‌⁪​‏⁪‎‭‫​‬‏‪‏‬⁫‍‪‮⁫‪​⁫‬⁫‏‍‬‬⁮‮⁪⁫⁫⁮‬‫‮()
    {
      // ISSUE: unable to decompile the method.
    }
  }

  [StructLayout(LayoutKind.Explicit, Size = 2240)]
  internal struct \u206D⁯‪‬​‎⁪⁬⁭‎‪​⁬​‪‌‮⁭⁭​‫‪‫‎‫‫‬‎⁮‏‫‫⁯‫​‏⁫‍⁯‏‮
  {
  }

  [StructLayout(LayoutKind.Explicit, Size = 448, Pack = 1)]
  internal struct \u202D⁯‮⁯‬⁯‬⁬⁫⁭⁬⁫⁬‭⁭⁯⁮⁬‭⁪‍‭⁮⁬⁪⁯⁮‪​‫⁯‫⁬‭‌⁫‍‍⁯‫‮
  {
  }
}
